"""
Next, we’re going to create our back-end in the following steps:

Flask set up
Creating tables
Adding routes
Protecting routes

注意——对于那些不知道flask-sqlalchemy的人，简单地说，
flask-sqlalchemy为我们提供了在数据库上执行CRUD操作的支持，
而无需编写原始SQL语句。

我们已经创建了一个新的博客模型，并添加了博客将包含的属性。
此外，我们还添加了一个名为serialize的函数，以便以JSON格式返回数据。

注意，我们还没有将tags属性添加到blog模型中。没有添加标签属性背后的原因是,
前5的属性博客很直接,然而,博客应该处理不同的标签属性自标签属性维护
一个多对多关系博客即每个博客可以有多个标签,每个标签的数量可以被添加到
多个博客的数量。

在处理多对多的关系,我们需要创建两个表,一个用于存储标签本身,
另一个将辅助表用于存储参考博客和标记即这个表将包含两列,
tag_id blog_id和这两列将作为外键的表分别标记和博客。



让我们创建第一个名为Tag的表，它将包含我们创建的所有标记。

接下来，让我们创建一个表来存储blog的引用和标记。



正如官方的flask-sqlalchemy文档中提到的，
我们不需要为这个表创建模型。


与blog模型中的其他属性不同，tags属性不是数据库中的一列。
它用于在Blog、Tag和tag_blog表之间创建连接。在上面的代码行中，
我们指定了Blog、Tag和tag_blog表之间的关系。
此外，在上面的代码行中，我们在标记表中创建了一个名为blogs_associated的新属性，
该属性可用于描述哪些博客与单个标记相关联。



注意——请记住，标记和blogs_associated属性不是数据库中的列，
因为它们是描述多对多关系的属性。
虽然它们不是列，但我们仍然可以同时查询这两个属性。

添加路线

在向应用程序中添加路由方法之前，我们需要在blog_routing .py中创建一个蓝图，
并将其导入到剩余的init余下的.py文件中。



注意——对于那些不了解蓝图的人来说，
蓝图为我们提供了一种将应用组织成更小的可重用组件的方法。
在本例中，我们将为博客创建一个蓝图，以便在蓝图中定义与博客相关的所有路由。


注意，我已经在路由中添加了一行@jwt_required。通过这样做，如果在头文件中不提供有效的JWT令牌，就不能访问此路由。为下列路线添加相同的代码行:



add_blog

update_blog

注意——不要忘记从flass -jwt扩展库中导入jwt_required。



要访问受保护的路由，需要提供以下格式的授权头:



不记名的YOUR_JWT_TOKEN



有了这个，我们就完成了对一些路线的保护。



在创建我们的数据库和运行我们的应用程序之前，我们需要记住几点:



导入剩余的.py文件的create_app函数中创建的所有模型
由于应用程序处于开发阶段，所以我在代码中存储了管理用户和JWT_SECRET_KEY。
当应用程序处于部署阶段时，应该进行更改。
本文没有对路由进行错误处理，因为每个开发人员都有不同的错误处理方法。
我们还没有为这个应用程序创建数据库。为此，在虚拟环境中运行以下命令:

python

从api导入db,create_app

db.create_all(应用= create_app ())
"""